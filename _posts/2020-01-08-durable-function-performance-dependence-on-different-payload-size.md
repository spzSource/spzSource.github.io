---
layout: post
title: "Azure Durable Functions: how payload size can impact performance"
date: 2020-01-09 23:30:00 +0300
categories: azure
tags: functions, azure, durable framework, performance, throughput
---

Azure Durable Functions extension is a very cool library that lets you write stateful functions in a serverless compute environment. The library allows you to write code in a same way you write asynchronous code, but instead of calling local async methods Azure Functions (Activity) are called. At a first look it might seem that there is no difference between regular async calls and durable calls, but it's not true.

Regular asynchronous code is handled by compiler by generating async state machine, so that async method is able to resume at the place where execution was suspended previously. But in case Durable Function (orchestrator) we do not have state machine generated by compiler. Instead the framework preserve execution history in external storage and then every time when orchestration function "wake up" it "plays back" execution history in order to determine what operations were already been executed and what operations have to be executed.

And sometimes this difference can cause performance issues if developer doesn't understand how durable framework works under the hood.

## Introduction

Let's go through visual exapmle to see how durable framework handles completion of activity operations.

```cs
[FunctionName("Orchestrator")]
public static async Task Run(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    await context.CallActivityAsync<string>("FirstActivity");

    await context.CallActivityAsync<string>("SecondActivity");
}
```

In a worst case an instance of orchestrator `Orchestrator` will be called two times due to the fact that the orchestrator contains two activity function, awaited separately. Based on that we can visualize execution flow:

#### First stage, when the orchestration function is awaited on `FirstActivity` activity function:

![Durable history reply - first stage]({{ "/assets/durable-functions-performance/Durable-Function-Stage-One.png" | absolute_url }})

**Notes**:

1. A new message was pushed by external caller to trigger orchestration first time.
2. QueueListener grabbed a new message from control queue and started function execution.
3. Durable host dump intention of running `FirstActivity` function.
4. Durable host pushed a message item into workitem queue to trigger `FirstActivity` function.
5. QueueListener grabbed the message from workitem queue and started activity function execution.
6. After the activity function completed (or failed) durable host dump this fact into Durable Storage.
7. A new message pushed to controll queue in order to trigger `Orchestrator` function to comtinue processing for supsequent activity functions.


#### Second stage, when the orchestration function is awaited on `SecondActivity` activity function:

![Durable history reply - second stage]({{ "/assets/durable-functions-performance/Durable-Function-Stage-Two.png" | absolute_url }})